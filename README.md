# Менеджер паролей

## Требования к установке

- В первую очередь, нужно установить OpenSSL. На Ubuntu или других Debian-like системах, установить можно так:

```bash
sudo apt-get update
sudo apt-get install libssl-dev
```

- Что бы скомпилировать код нужен **cmake**, если он не установлен - выполните:

```bash
sudo apt-get install cmake
```

## Запуск программы

- Для того что бы скомпилировать код, создайте директорию **build** и выполните команду **cmake**:

```bash
mkdir build && cd build
cmake ..
```

- Скомпилируйте при помощи:

```bash
make
```

- Можно запускать:

```bash
./checksums
```

## Описание задачи

**Цель:** Создать менеджер паролей для безопасного хранения и управления учетными данными пользователя.

**Функциональные требования:**

- [x] Менеджер паролей должен использовать шифрование для защиты учетных данных.
- [x] Пользователи должны иметь возможность создать новое защищенное хранилище с главным паролем.
- [x] Реализовать функции для добавления, чтения и удаления сохраненных паролей.
- [x] Создать простой пользовательский интерфейс через командную строку.
- [x] Реализовать обработку ошибок для отсутствующих файлов или прав на чтение.

## Описание

Для обеспечения безопасности хранимых паролей, используется несколько ступеней шифрования. <br>

1. Данные пользователя хранятся в файле с названием, которое получается при хешировании имени пользователя через
   алгоритм SHA256.
2. Для доступа в файл и расшифровки необходимо ввести мастер пароль, доступ будет получен, если SHA256 хеш введенного
   пароля совпадает с хранимым внутри файла хешем.
3. Данные в файле зашифрованы с помощью алгоритма KDF, ключом от которого являются сразу имя пользователя и его пароль.
4. Ни в один момент выполнения программы, данные не сохраняются на диске в открытом виде.

### Password.h

В заголовочном файле Password содержатся классы:

- **BasePassword** - абстрактный класс, от которого наследуются остальные пароли. Перегружает оператор == для сравнения
  паролей по хешу.
- **Password** - класс, который выполняет роль хранимого в БД пароля, а так же используется для верификации пароля,
  введенного при авторизации. При создании объекта для сверки пароля - текстовый пароль хешируется при помощи класса
  **HasherSHA256**.
- **MasterPassword** - класс, который отвечает за чтение мастер-пароля из файла пользователя и сверку его с паролем
  авторизации.

### PasswordHasher.h

По сути **PasswordHasher** это очень близкая копия классов типа **Hasher** из задачи "Проверка контрольных сумм файла".
Единственное отличие - это то, что в **AbstractPasswordHasher** в отличие от **AbstractHasher** нет привязки к файлу.
**AbstractPasswordHasher** и **HasherSHA256** используются для одностороннего шифрования паролей через SHA256.

### HasherKDF.h

Здесь описан класс **HasherKDF** который осуществляет **двустороннее** шифрование данных пользователя по алгоритму "Key
Derivation Function". В качестве ключа используются имя пользователя и хеш его мастер-пароля.

### User.h

Класс описывает два метода создания пользователя: регистрация и авторизация.

- При регистрации будет выполнена **registerSequence**, которая создаст для пользователя файл с введенными им данными.
  Файл будет содержать хеш имени пользователя (в названии) и хеш мастер-пароля (внутри). Если подходящей директории для
  файлов еще нет - она будет создана автоматически.
- При авторизации выполняется **authSequence**, которая при корректно введенном пароле откроет сам менеджер.

### Manager.h

Ну и наконец то, зачем мы здесь собрались - сам менеджер паролей.

1. При инициализации менеджер использует данные пользователя, что бы прочитать файл и расшифровать пароли.
2. Менеджер имеет меню, с помощью которого можно обратиться к его CRUD методам:
    - CREATE - добавить пароль
    - READ - показать все пароли
    - UPDATE - а где?
    - DELETE - удалить пароль
3. После каждой манипуляции, менеджер перезаписывает файл пользователя новыми данными (сохраняя мастер-пароль на месте).

## Возможные улучшения

- Для повышения надежности KDF шифрования следует добавить к ключу "соль", которая получалась бы по определенному (
  тайному) алгоритму из имени пользователя.
- Проблемой с безопасностью является то, что для одного пользователя создается один файл, лежащий в открытом доступе.
  Если файл всего один или их мало, имя пользователя можно легко просто угадать, зная имя/частый ник владельца
  устройства. Возможным решением является **обфускация** - файлы маленькие, ничего не весят, можно
  создавать сразу не один файл для пользователя, а, скажем, тысячу, что бы усложнить задачу возможному противнику. Плюс
  заполнить файлы большим количеством мусорных значений, программа, расшифровав файл сразу может понять, какие из них -
  настоящие пароли, а какие - болванки.
- Самая страшная беда менеджеров паролей - это когда забываешь мастер-пароль. Можно добавить к нему подсказку и
  показывать, если введен неверный пароль.
- В данный момент в данных пользователя хранятся четко 64 символа мастер-пароля на первой строчке и по 32 символа
  обычных паролей. С учетом того, что есть четкая структура, можно хранить их все в одну строку, что усложнит чтение
  файла условным противником.
